<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate AI Chase Tag</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-wrapper {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1100px;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 1.1em;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .player-info {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .player-info.red {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .player-info.green {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .player-name {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-score {
            font-size: 2.5em;
            font-weight: bold;
        }

        .player-role {
            font-size: 0.9em;
            margin-top: 5px;
            opacity: 0.9;
        }

        .timer-box {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            min-width: 150px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .timer-label {
            font-size: 1em;
            margin-bottom: 5px;
        }

        .timer-value {
            font-size: 3em;
            font-weight: bold;
        }

        .canvas-container {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        canvas {
            display: block;
            background: #656560;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            padding: 15px 35px;
            font-size: 1.1em;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #999;
        }

        .status-panel {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .stat-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .stat-card p {
            color: #495057;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .pulsing {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <h1>Ultimate AI Chase Tag</h1>
        <p class="subtitle">Where the Evader Never Gets Caught!</p>

        <div class="game-header">
            <div class="player-info red">
                <div class="player-name"> Red AI</div>
                <div class="player-score" id="redScore">0</div>
                <div class="player-role" id="redRole">Waiting...</div>
            </div>

            <div class="timer-box">
                <div class="timer-label"> TIME</div>
                <div class="timer-value" id="timer">40</div>
            </div>

            <div class="player-info green">
                <div class="player-name"> Green AI</div>
                <div class="player-score" id="greenScore">0</div>
                <div class="player-role" id="greenRole">Waiting...</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas" width="1000" height="700"></canvas>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="startGame()"> START GAME</button>
            <button id="pauseBtn" onclick="togglePause()">PAUSE</button>
            <button onclick="resetGame()"> RESET</button>
        </div>

        <div class="status-panel" id="status">
            Click START GAME to watch the ultimate AI battle!
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <h3> Chaser AI Strategy</h3>
                <p id="chaserStats">Uses A* pathfinding to pursue the evader with optimal path calculation.</p>
            </div>
            <div class="stat-card">
                <h3> Evader AI Strategy</h3>
                <p id="evaderStats">Uses Potential Field + A* + Minimax to maintain maximum distance and never get caught.</p>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot" style="background: #ff6b6b;"></div>
                <span>Red AI Player</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #51cf66;"></div>
                <span>Green AI Player</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #4a5568;"></div>
                <span>Obstacles</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #ffd93d;"></div>
                <span>Speed Powerup</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #ffd93d; box-shadow: 0 0 10px #ffd93d;"></div>
                <span>Active Chaser</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Configuration
        const CONFIG = {
            CANVAS_WIDTH: 1000,
            CANVAS_HEIGHT: 700,
            GRID_SIZE: 25,
            ROUND_TIME: 20,
            CHASER_SPEED: 2.5,
            EVADER_SPEED: 3.8,
            PLAYER_SIZE: 16,
            SAFE_DISTANCE: 150,
            CRITICAL_DISTANCE: 80,
            WIN_SCORE: 5,
            POWERUP_SPEED_BOOST: 1.5,
            POWERUP_DURATION: 3,
            POWERUP_SIZE: 15,
            POWERUP_SPAWN_MIN: 3,
            POWERUP_SPAWN_MAX: 7
        };

        // Game State
        let gameState = {
            running: false,
            paused: false,
            time: CONFIG.ROUND_TIME,
            redScore: 0,
            greenScore: 0,
            currentChaser: 'RED',
            roundTimer: null,
            transitioning: false,
            transitionCounter: 3,
            gameOver: false,
            winner: null,
            playerRed: { x: 100, y: 350, size: CONFIG.PLAYER_SIZE, speedBoost: 1, boostTimer: 0 },
            playerGreen: { x: 900, y: 350, size: CONFIG.PLAYER_SIZE, speedBoost: 1, boostTimer: 0 },
            obstacles: [],
            powerup: null,
            powerupTimer: null,
            nextPowerupTime: 0
        };

        // Initialize Optimal Obstacle Layout
        function initObstacles() {
            const obstacles = [];
            
            // Border walls
            obstacles.push(
                { x: 0, y: 0, width: 1000, height: 20 },
                { x: 0, y: 680, width: 1000, height: 20 },
                { x: 0, y: 0, width: 20, height: 700 },
                { x: 980, y: 0, width: 20, height: 700 }
            );

            // Strategic maze layout - creates multiple paths but no dead ends
            // Vertical barriers
            const verticals = [
                { x: 200, y: 100, h: 150 },
                { x: 350, y: 250, h: 200 },
                { x: 500, y: 50, h: 180 },
                { x: 650, y: 270, h: 180 },
                { x: 800, y: 100, h: 150 },
                { x: 250, y: 450, h: 150 },
                { x: 450, y: 420, h: 180 },
                { x: 750, y: 450, h: 150 }
            ];

            verticals.forEach(v => {
                obstacles.push({ x: v.x, y: v.y, width: 25, height: v.h });
            });

            // Horizontal barriers
            const horizontals = [
                { x: 100, y: 150, w: 150 },
                { x: 300, y: 200, w: 180 },
                { x: 550, y: 250, w: 150 },
                { x: 750, y: 200, w: 150 },
                { x: 150, y: 350, w: 120 },
                { x: 400, y: 380, w: 150 },
                { x: 700, y: 350, w: 120 },
                { x: 200, y: 500, w: 150 },
                { x: 500, y: 550, w: 180 },
                { x: 750, y: 500, w: 100 }
            ];

            horizontals.forEach(h => {
                obstacles.push({ x: h.x, y: h.y, width: h.w, height: 25 });
            });

            // Central complex structure with multiple exits
            obstacles.push(
                { x: 450, y: 300, width: 100, height: 25 },
                { x: 450, y: 300, width: 25, height: 100 },
                { x: 525, y: 300, width: 25, height: 100 },
                { x: 450, y: 375, width: 100, height: 25 }
            );

            return obstacles;
        }

        // Powerup Management
        function spawnPowerup() {
            if (gameState.transitioning || !gameState.running) return;

            const pathfinder = new AStarPathfinder(gameState.obstacles);
            let attempts = 0;
            let validPosition = false;
            let x, y;

            // Find valid spawn position (not in obstacles, not too close to players)
            while (!validPosition && attempts < 100) {
                x = Math.random() * (CONFIG.CANVAS_WIDTH - 100) + 50;
                y = Math.random() * (CONFIG.CANVAS_HEIGHT - 100) + 50;

                const redDist = Math.sqrt(Math.pow(x - gameState.playerRed.x, 2) + Math.pow(y - gameState.playerRed.y, 2));
                const greenDist = Math.sqrt(Math.pow(x - gameState.playerGreen.x, 2) + Math.pow(y - gameState.playerGreen.y, 2));

                if (pathfinder.isValidPosition(x, y, 20) && redDist > 100 && greenDist > 100) {
                    validPosition = true;
                }
                attempts++;
            }

            if (validPosition) {
                gameState.powerup = { x, y, active: true };
                
                // Schedule next powerup
                const nextSpawnDelay = (Math.random() * (CONFIG.POWERUP_SPAWN_MAX - CONFIG.POWERUP_SPAWN_MIN) + CONFIG.POWERUP_SPAWN_MIN) * 1000;
                gameState.powerupTimer = setTimeout(spawnPowerup, nextSpawnDelay);
            }
        }

        function checkPowerupCollection() {
            if (!gameState.powerup || !gameState.powerup.active) return;

            const redDist = Math.sqrt(
                Math.pow(gameState.playerRed.x - gameState.powerup.x, 2) + 
                Math.pow(gameState.playerRed.y - gameState.powerup.y, 2)
            );
            const greenDist = Math.sqrt(
                Math.pow(gameState.playerGreen.x - gameState.powerup.x, 2) + 
                Math.pow(gameState.playerGreen.y - gameState.powerup.y, 2)
            );

            if (redDist < CONFIG.PLAYER_SIZE + CONFIG.POWERUP_SIZE) {
                applyPowerup(gameState.playerRed, 'RED');
                gameState.powerup = null;
            } else if (greenDist < CONFIG.PLAYER_SIZE + CONFIG.POWERUP_SIZE) {
                applyPowerup(gameState.playerGreen, 'GREEN');
                gameState.powerup = null;
            }
        }

        function applyPowerup(player, playerName) {
            player.speedBoost = CONFIG.POWERUP_SPEED_BOOST;
            player.boostTimer = CONFIG.POWERUP_DURATION;

            const role = (playerName === gameState.currentChaser) ? 'CHASER' : 'EVADER';
            updateStatus(` ${playerName} AI collected SPEED BOOST! (${role})`);

            // Remove boost after duration
            const boostInterval = setInterval(() => {
                player.boostTimer--;
                if (player.boostTimer <= 0) {
                    player.speedBoost = 1;
                    clearInterval(boostInterval);
                }
            }, 1000);
        }

        function shouldChaserGoForPowerup(chaser, evader, powerup) {
            if (!powerup || !powerup.active) return false;

            const distToPowerup = Math.sqrt(
                Math.pow(chaser.x - powerup.x, 2) + 
                Math.pow(chaser.y - powerup.y, 2)
            );
            const distToEvader = Math.sqrt(
                Math.pow(chaser.x - evader.x, 2) + 
                Math.pow(chaser.y - evader.y, 2)
            );

            // Calculate if evader can reach powerup first
            const evaderDistToPowerup = Math.sqrt(
                Math.pow(evader.x - powerup.x, 2) + 
                Math.pow(evader.y - powerup.y, 2)
            );

            const chaserSpeed = CONFIG.CHASER_SPEED * chaser.speedBoost;
            const evaderSpeed = CONFIG.EVADER_SPEED * evader.speedBoost;

            const chaserTime = distToPowerup / chaserSpeed;
            const evaderTime = evaderDistToPowerup / evaderSpeed;

            // Don't go for powerup if:
            // 1. Evader will get it first
            // 2. It's too far and evader is close (opportunity cost)
            // 3. Already have speed boost
            if (chaser.speedBoost > 1) return false;
            if (evaderTime < chaserTime * 0.8) return false;
            if (distToPowerup > 300 && distToEvader < 200) return false;

            // Go for powerup if it's close or evader is far
            if (distToPowerup < 150) return true;
            if (distToEvader > 300 && distToPowerup < 400) return true;

            return false;
        }

        function shouldEvaderGoForPowerup(evader, chaser, powerup) {
            if (!powerup || !powerup.active) return false;

            const distToPowerup = Math.sqrt(
                Math.pow(evader.x - powerup.x, 2) + 
                Math.pow(evader.y - powerup.y, 2)
            );
            const distFromChaser = Math.sqrt(
                Math.pow(evader.x - chaser.x, 2) + 
                Math.pow(evader.y - chaser.y, 2)
            );

            // Calculate if chaser can reach powerup first
            const chaserDistToPowerup = Math.sqrt(
                Math.pow(chaser.x - powerup.x, 2) + 
                Math.pow(chaser.y - powerup.y, 2)
            );

            const evaderSpeed = CONFIG.EVADER_SPEED * evader.speedBoost;
            const chaserSpeed = CONFIG.CHASER_SPEED * chaser.speedBoost;

            const evaderTime = distToPowerup / evaderSpeed;
            const chaserTime = chaserDistToPowerup / chaserSpeed;

            // Calculate distance from powerup to chaser
            const powerupToChaserDist = chaserDistToPowerup;

            // Don't go for powerup if:
            // 1. Already have speed boost
            // 2. Chaser will get it first by significant margin
            // 3. It's too close to chaser (dangerous)
            // 4. Going for it would put evader in danger
            if (evader.speedBoost > 1) return false;
            if (chaserTime < evaderTime * 0.7) return false;
            if (powerupToChaserDist < 100) return false;
            
            // Check if path to powerup goes through chaser
            const powerupDirX = powerup.x - evader.x;
            const powerupDirY = powerup.y - evader.y;
            const chaserDirX = chaser.x - evader.x;
            const chaserDirY = chaser.y - evader.y;
            
            const powerupDist = Math.sqrt(powerupDirX * powerupDirX + powerupDirY * powerupDirY);
            const chaserDist = Math.sqrt(chaserDirX * chaserDirX + chaserDirY * chaserDirY);
            
            if (powerupDist > 0 && chaserDist > 0) {
                const dotProduct = (powerupDirX * chaserDirX + powerupDirY * chaserDirY) / (powerupDist * chaserDist);
                // If angle is less than 60 degrees and chaser is close, it's dangerous
                if (dotProduct > 0.5 && distFromChaser < CONFIG.SAFE_DISTANCE) return false;
            }

            // After getting powerup, check if evader can still maintain safe distance
            const distAfterCollection = Math.sqrt(
                Math.pow(powerup.x - chaser.x, 2) + 
                Math.pow(powerup.y - chaser.y, 2)
            );

            // Don't go if powerup position is too dangerous
            if (distAfterCollection < CONFIG.CRITICAL_DISTANCE) return false;

            // Go for powerup if:
            // 1. Can reach it significantly before chaser
            // 2. Currently at safe distance from chaser
            // 3. Powerup is not too far
            if (evaderTime < chaserTime * 0.9 && distFromChaser > CONFIG.SAFE_DISTANCE && distToPowerup < 350) {
                return true;
            }

            return false;
        }

        // A* Pathfinding Algorithm
        class AStarPathfinder {
            constructor(obstacles) {
                this.obstacles = obstacles;
                this.gridSize = CONFIG.GRID_SIZE;
            }

            isValidPosition(x, y, padding = 10) {
                if (x < 30 || y < 30 || x >= CONFIG.CANVAS_WIDTH - 30 || y >= CONFIG.CANVAS_HEIGHT - 30) {
                    return false;
                }

                for (let obs of this.obstacles) {
                    if (x + padding > obs.x && 
                        x - padding < obs.x + obs.width &&
                        y + padding > obs.y && 
                        y - padding < obs.y + obs.height) {
                        return false;
                    }
                }
                return true;
            }

            getNeighbors(node) {
                const neighbors = [];
                const moves = [
                    { dx: -1, dy: 0, cost: 1 },
                    { dx: 1, dy: 0, cost: 1 },
                    { dx: 0, dy: -1, cost: 1 },
                    { dx: 0, dy: 1, cost: 1 },
                    { dx: -1, dy: -1, cost: 1.414 },
                    { dx: 1, dy: -1, cost: 1.414 },
                    { dx: -1, dy: 1, cost: 1.414 },
                    { dx: 1, dy: 1, cost: 1.414 }
                ];

                for (let move of moves) {
                    const newX = node.x + move.dx * this.gridSize;
                    const newY = node.y + move.dy * this.gridSize;
                    
                    if (this.isValidPosition(newX, newY)) {
                        neighbors.push({ x: newX, y: newY, cost: move.cost });
                    }
                }

                return neighbors;
            }

            heuristic(a, b) {
                return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
            }

            findPath(start, goal) {
                const startNode = {
                    x: Math.round(start.x / this.gridSize) * this.gridSize,
                    y: Math.round(start.y / this.gridSize) * this.gridSize,
                    g: 0,
                    h: 0,
                    f: 0,
                    parent: null
                };

                const goalNode = {
                    x: Math.round(goal.x / this.gridSize) * this.gridSize,
                    y: Math.round(goal.y / this.gridSize) * this.gridSize
                };

                const openSet = [startNode];
                const closedSet = new Set();
                
                let iterations = 0;
                const MAX_ITERATIONS = 1000; // CRITICAL: Prevent infinite loops

                while (openSet.length > 0 && iterations < MAX_ITERATIONS) {
                    iterations++;
                    
                    openSet.sort((a, b) => a.f - b.f);
                    const current = openSet.shift();

                    const key = `${current.x},${current.y}`;
                    if (closedSet.has(key)) continue;

                    if (current.x === goalNode.x && current.y === goalNode.y) {
                        const path = [];
                        let node = current;
                        while (node.parent) {
                            path.unshift({ x: node.x, y: node.y });
                            node = node.parent;
                        }
                        return path;
                    }

                    closedSet.add(key);

                    for (let neighbor of this.getNeighbors(current)) {
                        const nKey = `${neighbor.x},${neighbor.y}`;
                        if (closedSet.has(nKey)) continue;

                        const g = current.g + neighbor.cost * this.gridSize;
                        const h = this.heuristic(neighbor, goalNode);
                        const f = g + h;

                        const existing = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
                        
                        if (!existing || g < existing.g) {
                            const newNode = { x: neighbor.x, y: neighbor.y, g, h, f, parent: current };
                            if (!existing) {
                                openSet.push(newNode);
                            } else {
                                Object.assign(existing, newNode);
                            }
                        }
                    }
                }

                return [];
            }
        }

        // Advanced Evader AI with Multiple Strategies
        class OptimalEvaderAI {
            constructor(obstacles) {
                this.obstacles = obstacles;
                this.pathfinder = new AStarPathfinder(obstacles);
                this.gridSize = CONFIG.GRID_SIZE;
            }

            distance(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }

            // Potential Field Method - creates repulsive force from chaser
            calculatePotentialField(evader, chaser) {
                const dist = this.distance(evader, chaser);
                if (dist === 0) return { x: 0, y: 0 };

                const dx = evader.x - chaser.x;
                const dy = evader.y - chaser.y;

                // Repulsive force (stronger when closer)
                const force = Math.min(200 / (dist + 1), 10);
                
                return {
                    x: (dx / dist) * force,
                    y: (dy / dist) * force
                };
            }

            // Find all safe positions (far from chaser, with multiple exits)
            findSafePositions(evader, chaser) {
                const safePositions = [];
                
                for (let x = 50; x < CONFIG.CANVAS_WIDTH - 50; x += this.gridSize) {
                    for (let y = 50; y < CONFIG.CANVAS_HEIGHT - 50; y += this.gridSize) {
                        if (!this.pathfinder.isValidPosition(x, y, 15)) continue;

                        const distFromChaser = this.distance({ x, y }, chaser);
                        const neighbors = this.pathfinder.getNeighbors({ x, y });
                        const exitCount = neighbors.length;

                        // Only consider positions that are:
                        // 1. Far from chaser
                        // 2. Have multiple escape routes (not corners)
                        if (distFromChaser > CONFIG.SAFE_DISTANCE && exitCount >= 5) {
                            const distFromEvader = this.distance({ x, y }, evader);
                            safePositions.push({
                                x, y,
                                score: distFromChaser * 2 + exitCount * 20 - distFromEvader * 0.5,
                                exitCount,
                                distFromChaser
                            });
                        }
                    }
                }

                safePositions.sort((a, b) => b.score - a.score);
                return safePositions.slice(0, 10);
            }

            // Predict chaser's future positions
            predictChaserPath(chaser, evader, steps = 5) {
                const predictions = [];
                let currentPos = { ...chaser };
                
                for (let i = 0; i < steps; i++) {
                    const dx = evader.x - currentPos.x;
                    const dy = evader.y - currentPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        currentPos.x += (dx / dist) * CONFIG.CHASER_SPEED;
                        currentPos.y += (dy / dist) * CONFIG.CHASER_SPEED;
                        predictions.push({ ...currentPos });
                    }
                }
                
                return predictions;
            }

            // Evaluate move safety
            evaluateMoveSafety(position, chaser, chaserPredictions) {
                let safety = 0;

                // Distance from current chaser position
                const currentDist = this.distance(position, chaser);
                safety += currentDist * 2;

                // Distance from predicted chaser positions
                for (let pred of chaserPredictions) {
                    const predDist = this.distance(position, pred);
                    safety += predDist;
                }

                // Number of escape routes
                const neighbors = this.pathfinder.getNeighbors(position);
                safety += neighbors.length * 30;

                // Penalty for being near edges
                const edgeDist = Math.min(
                    position.x - 30,
                    position.y - 30,
                    CONFIG.CANVAS_WIDTH - position.x - 30,
                    CONFIG.CANVAS_HEIGHT - position.y - 30
                );
                safety += Math.min(edgeDist, 100);

                return safety;
            }

            // Main decision function
            decideBestMove(evader, chaser) {
                const distToChaser = this.distance(evader, chaser);

                // Emergency mode: chaser is very close
                if (distToChaser < CONFIG.CRITICAL_DISTANCE) {
                    return this.emergencyEscape(evader, chaser);
                }

                // Normal mode: maintain optimal distance
                if (distToChaser < CONFIG.SAFE_DISTANCE) {
                    return this.tacticalRetreat(evader, chaser);
                }

                // Safe mode: move to strategic position
                return this.strategicPositioning(evader, chaser);
            }

            emergencyEscape(evader, chaser) {
                const chaserPredictions = this.predictChaserPath(chaser, evader, 8);
                const potentialField = this.calculatePotentialField(evader, chaser);
                
                // Get all possible moves
                const neighbors = this.pathfinder.getNeighbors(evader);
                
                let bestMove = null;
                let bestSafety = -Infinity;

                for (let neighbor of neighbors) {
                    // Skip if too few escape routes (dead end)
                    const escapeRoutes = this.pathfinder.getNeighbors(neighbor).length;
                    if (escapeRoutes < 4) continue;

                    // Calculate safety score
                    const safety = this.evaluateMoveSafety(neighbor, chaser, chaserPredictions);
                    
                    // Bonus for moving in potential field direction
                    const fieldAlignment = 
                        (neighbor.x - evader.x) * potentialField.x +
                        (neighbor.y - evader.y) * potentialField.y;

                    const totalScore = safety + fieldAlignment * 5;

                    if (totalScore > bestSafety) {
                        bestSafety = totalScore;
                        bestMove = neighbor;
                    }
                }

                // FIX: If no move with 4+ routes found, pick ANY neighbor farthest from chaser
                if (!bestMove && neighbors.length > 0) {
                    bestMove = neighbors[0];
                    let maxDist = this.distance(bestMove, chaser);
                    
                    for (let i = 1; i < neighbors.length; i++) {
                        const dist = this.distance(neighbors[i], chaser);
                        if (dist > maxDist) {
                            maxDist = dist;
                            bestMove = neighbors[i];
                        }
                    }
                }

                return bestMove;
            }

            tacticalRetreat(evader, chaser) {
                const safePositions = this.findSafePositions(evader, chaser);
                const chaserPredictions = this.predictChaserPath(chaser, evader, 5);

                // Try to reach a safe position
                for (let safePos of safePositions) {
                    const path = this.pathfinder.findPath(evader, safePos);
                    
                    if (path.length > 0) {
                        // Check if path is safe
                        let pathSafe = true;
                        const checkPoints = path.slice(0, 3);
                        
                        for (let point of checkPoints) {
                            for (let pred of chaserPredictions) {
                                if (this.distance(point, pred) < CONFIG.CRITICAL_DISTANCE) {
                                    pathSafe = false;
                                    break;
                                }
                            }
                            if (!pathSafe) break;
                        }

                        if (pathSafe) {
                            return path[0];
                        }
                    }
                }

                // Fallback to emergency escape
                return this.emergencyEscape(evader, chaser);
            }

            strategicPositioning(evader, chaser) {
                const safePositions = this.findSafePositions(evader, chaser);

                // Head to the safest position
                for (let safePos of safePositions) {
                    const path = this.pathfinder.findPath(evader, safePos);
                    
                    if (path.length > 0) {
                        // Ensure we're not moving closer to chaser
                        const currentDist = this.distance(evader, chaser);
                        const nextDist = this.distance(path[0], chaser);
                        
                        if (nextDist >= currentDist * 0.9) {
                            return path[0];
                        }
                    }
                }

                // Maintain current position if already safe
                return evader;
            }
        }

        // Initialize AI
        let chaserAI = null;
        let evaderAI = null;

        function initGame() {
            gameState.obstacles = initObstacles();
            chaserAI = new AStarPathfinder(gameState.obstacles);
            evaderAI = new OptimalEvaderAI(gameState.obstacles);
            render();
        }

        // AI Movement
        function moveChaser() {
            const chaser = gameState.currentChaser === 'RED' ? gameState.playerRed : gameState.playerGreen;
            const evader = gameState.currentChaser === 'RED' ? gameState.playerGreen : gameState.playerRed;

            let target = evader;
            let pursuing = 'evader';

            // Check if should go for powerup
            if (gameState.powerup && shouldChaserGoForPowerup(chaser, evader, gameState.powerup)) {
                target = gameState.powerup;
                pursuing = 'powerup';
            }

            let path = chaserAI.findPath(chaser, target);
            
            // FIX: If path to powerup fails, fallback to chasing evader
            if (path.length === 0 && pursuing === 'powerup') {
                target = evader;
                pursuing = 'evader';
                path = chaserAI.findPath(chaser, target);
            }
            
            // ULTIMATE FALLBACK: If pathfinding completely fails, move directly toward target
            if (path.length === 0) {
                const dx = target.x - chaser.x;
                const dy = target.y - chaser.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 1) {
                    const speed = CONFIG.CHASER_SPEED * chaser.speedBoost;
                    const moveX = (dx / dist) * speed;
                    const moveY = (dy / dist) * speed;
                    
                    // Check if this move is valid (not into obstacle)
                    const newX = chaser.x + moveX;
                    const newY = chaser.y + moveY;
                    
                    if (chaserAI.isValidPosition(newX, newY, 10)) {
                        chaser.x = newX;
                        chaser.y = newY;
                    } else {
                        // Try moving only in X direction
                        if (chaserAI.isValidPosition(chaser.x + moveX, chaser.y, 10)) {
                            chaser.x += moveX;
                        } 
                        // Try moving only in Y direction
                        else if (chaserAI.isValidPosition(chaser.x, chaser.y + moveY, 10)) {
                            chaser.y += moveY;
                        }
                    }
                }
                
                document.getElementById('chaserStats').textContent = 
                    `Direct pursuit (no path). Distance: ${Math.round(dist)}px.`;
                return;
            }
            
            // Normal pathfinding movement
            if (path.length > 0) {
                const nextStep = path[0];
                const dx = nextStep.x - chaser.x;
                const dy = nextStep.y - chaser.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const speed = CONFIG.CHASER_SPEED * chaser.speedBoost;
                    chaser.x += (dx / dist) * speed;
                    chaser.y += (dy / dist) * speed;
                }

                // Update stats
                const chaserColor = gameState.currentChaser === 'RED' ? 'red' : 'green';
                const boostText = chaser.speedBoost > 1 ? ` BOOSTED (${chaser.boostTimer}s)` : '';
                const targetText = pursuing === 'powerup' ? ' GOING FOR POWERUP!' : `Pursuing evader`;
                document.getElementById('chaserStats').textContent = 
                    `${targetText}. Distance: ${Math.round(dist)}px. Path: ${path.length} nodes.${boostText}`;
            }
        }

        function moveEvader() {
            const evader = gameState.currentChaser === 'RED' ? gameState.playerGreen : gameState.playerRed;
            const chaser = gameState.currentChaser === 'RED' ? gameState.playerRed : gameState.playerGreen;

            let bestMove = null;
            let goingForPowerup = false;

            // Check if should go for powerup
            if (gameState.powerup && shouldEvaderGoForPowerup(evader, chaser, gameState.powerup)) {
                const pathToPowerup = evaderAI.pathfinder.findPath(evader, gameState.powerup);
                if (pathToPowerup.length > 0) {
                    bestMove = pathToPowerup[0];
                    goingForPowerup = true;
                }
            }

            // If not going for powerup, use normal evasion logic
            if (!bestMove) {
                bestMove = evaderAI.decideBestMove(evader, chaser);
            }
            
            // ULTIMATE FALLBACK: If AI returns nothing, move directly AWAY from chaser
            if (!bestMove) {
                const dx = evader.x - chaser.x;
                const dy = evader.y - chaser.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const speed = CONFIG.EVADER_SPEED * evader.speedBoost;
                    const moveX = (dx / dist) * speed;
                    const moveY = (dy / dist) * speed;
                    
                    // Check if this move is valid
                    const newX = evader.x + moveX;
                    const newY = evader.y + moveY;
                    
                    if (evaderAI.pathfinder.isValidPosition(newX, newY, 10)) {
                        evader.x = newX;
                        evader.y = newY;
                    } else {
                        // Try moving only in X direction
                        if (evaderAI.pathfinder.isValidPosition(evader.x + moveX, evader.y, 10)) {
                            evader.x += moveX;
                        } 
                        // Try moving only in Y direction
                        else if (evaderAI.pathfinder.isValidPosition(evader.x, evader.y + moveY, 10)) {
                            evader.y += moveY;
                        }
                        // If completely stuck, try ANY direction
                        else {
                            const directions = [
                                {x: speed, y: 0}, {x: -speed, y: 0},
                                {x: 0, y: speed}, {x: 0, y: -speed},
                                {x: speed*0.7, y: speed*0.7}, {x: -speed*0.7, y: speed*0.7},
                                {x: speed*0.7, y: -speed*0.7}, {x: -speed*0.7, y: -speed*0.7}
                            ];
                            for (let dir of directions) {
                                if (evaderAI.pathfinder.isValidPosition(evader.x + dir.x, evader.y + dir.y, 10)) {
                                    evader.x += dir.x;
                                    evader.y += dir.y;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                const distToChaser = Math.sqrt((evader.x - chaser.x)**2 + (evader.y - chaser.y)**2);
                document.getElementById('evaderStats').textContent = 
                    `Mode: Direct escape (no path). Distance: ${Math.round(distToChaser)}px.`;
                return;
            }
            
            // Normal AI movement
            if (bestMove) {
                const dx = bestMove.x - evader.x;
                const dy = bestMove.y - evader.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const speed = CONFIG.EVADER_SPEED * evader.speedBoost;
                    evader.x += (dx / dist) * speed;
                    evader.y += (dy / dist) * speed;
                }

                const distToChaser = evaderAI.distance(evader, chaser);
                let mode = 'Strategic Positioning';
                if (goingForPowerup) {
                    mode = ' GOING FOR POWERUP';
                } else if (distToChaser < CONFIG.CRITICAL_DISTANCE) {
                    mode = ' EMERGENCY ESCAPE';
                } else if (distToChaser < CONFIG.SAFE_DISTANCE) {
                    mode = 'Tactical Retreat';
                }

                const boostText = evader.speedBoost > 1 ? `BOOSTED (${evader.boostTimer}s)` : '';
                document.getElementById('evaderStats').textContent = 
                    `Mode: ${mode}. Distance from chaser: ${Math.round(distToChaser)}px.${boostText}`;
            }
        }

        // Check collision
        function checkCollision() {
            const dx = gameState.playerRed.x - gameState.playerGreen.x;
            const dy = gameState.playerRed.y - gameState.playerGreen.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < (CONFIG.PLAYER_SIZE * 2);
        }

        // Game Loop
        function gameLoop() {
            if (!gameState.running || gameState.paused) return;

            moveChaser();
            moveEvader();
            checkPowerupCollection();

            if (checkCollision()) {
                handleTag();
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        function handleTag() {
            const winner = gameState.currentChaser;
            
            if (winner === 'RED') {
                gameState.redScore++;
                updateStatus(' RED AI tagged GREEN AI! Red scores! (Rare achievement!)');
            } else {
                gameState.greenScore++;
                updateStatus(' GREEN AI tagged RED AI! Green scores! (Rare achievement!)');
            }

            endRound();
        }

        // Render
        function render() {
            // Clear canvas
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.CANVAS_HEIGHT);
            gradient.addColorStop(0, '#1a1f36');
            gradient.addColorStop(1, '#0f1419');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x < CONFIG.CANVAS_WIDTH; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CONFIG.CANVAS_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y < CONFIG.CANVAS_HEIGHT; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CONFIG.CANVAS_WIDTH, y);
                ctx.stroke();
            }

            // Draw obstacles
            ctx.fillStyle = '#4a5568';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            
            for (let obs of gameState.obstacles) {
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            }
            
            ctx.shadowBlur = 0;

            // Draw players
            drawPlayer(gameState.playerRed.x, gameState.playerRed.y, '#ff6b6b', gameState.currentChaser === 'RED');
            drawPlayer(gameState.playerGreen.x, gameState.playerGreen.y, '#51cf66', gameState.currentChaser === 'GREEN');

            // Draw powerup
            if (gameState.powerup && gameState.powerup.active) {
                drawPowerup(gameState.powerup.x, gameState.powerup.y);
            }

            // Update UI
            document.getElementById('redScore').textContent = gameState.redScore;
            document.getElementById('greenScore').textContent = gameState.greenScore;
            document.getElementById('timer').textContent = gameState.time;

            const redRole = gameState.currentChaser === 'RED' ? ' CHASER' : ' EVADER';
            const greenRole = gameState.currentChaser === 'GREEN' ? ' CHASER' : ' EVADER';
            document.getElementById('redRole').textContent = redRole;
            document.getElementById('greenRole').textContent = greenRole;

            // Transition overlay
            if (gameState.transitioning) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Next Round Starting...', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 - 30);
                
                ctx.font = 'bold 32px Arial';
                const nextChaser = gameState.currentChaser === 'RED' ? 'RED' : 'GREEN';
                ctx.fillText(`${nextChaser} will chase!`, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 30);
                
                ctx.font = 'bold 64px Arial';
                ctx.fillStyle = '#ffd93d';
                ctx.fillText(`${gameState.transitionCounter}`, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 100);
            }

            // Game Over Screen
            if (gameState.gameOver) {
                // Dark overlay with gradient
                const gradient = ctx.createRadialGradient(
                    CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2, 0,
                    CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2, CONFIG.CANVAS_WIDTH / 2
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.85)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

                // Trophy/Winner icon (simple star shape)
                ctx.save();
                ctx.translate(CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 - 150);
                ctx.fillStyle = '#ffd93d';
                ctx.shadowColor = 'rgba(255, 217, 61, 0.8)';
                ctx.shadowBlur = 30;
                
                // Draw star
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const x1 = Math.cos(angle) * 40;
                    const y1 = Math.sin(angle) * 40;
                    if (i === 0) ctx.moveTo(x1, y1);
                    else ctx.lineTo(x1, y1);
                    const angle2 = angle + (2 * Math.PI) / 5;
                    const x2 = Math.cos(angle2) * 16;
                    const y2 = Math.sin(angle2) * 16;
                    ctx.lineTo(x2, y2);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                ctx.shadowBlur = 0;

                // "GAME OVER" text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 72px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                ctx.shadowBlur = 20;
                ctx.fillText('GAME OVER', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 - 50);
                ctx.shadowBlur = 0;

                // Winner announcement
                const winnerColor = gameState.winner === 'RED' ? '#ff6b6b' : '#51cf66';
                ctx.fillStyle = winnerColor;
                ctx.font = 'bold 56px Arial';
                ctx.shadowColor = winnerColor;
                ctx.shadowBlur = 25;
                ctx.fillText(`${gameState.winner} AI WINS!`, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 30);
                ctx.shadowBlur = 0;

                // Final score display
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 32px Arial';
                ctx.fillText('FINAL SCORE', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 90);

                // Score boxes
                const boxY = CONFIG.CANVAS_HEIGHT / 2 + 130;
                const boxWidth = 180;
                const boxHeight = 80;
                const spacing = 40;

                // Red score box
                ctx.fillStyle = 'rgba(255, 107, 107, 0.3)';
                ctx.fillRect(CONFIG.CANVAS_WIDTH / 2 - boxWidth - spacing / 2, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 3;
                ctx.strokeRect(CONFIG.CANVAS_WIDTH / 2 - boxWidth - spacing / 2, boxY, boxWidth, boxHeight);
                
                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('RED AI', CONFIG.CANVAS_WIDTH / 2 - boxWidth / 2 - spacing / 2, boxY + 30);
                ctx.font = 'bold 36px Arial';
                ctx.fillText(gameState.redScore, CONFIG.CANVAS_WIDTH / 2 - boxWidth / 2 - spacing / 2, boxY + 65);

                // Green score box
                ctx.fillStyle = 'rgba(81, 207, 102, 0.3)';
                ctx.fillRect(CONFIG.CANVAS_WIDTH / 2 + spacing / 2, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = '#51cf66';
                ctx.lineWidth = 3;
                ctx.strokeRect(CONFIG.CANVAS_WIDTH / 2 + spacing / 2, boxY, boxWidth, boxHeight);
                
                ctx.fillStyle = '#51cf66';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('GREEN AI', CONFIG.CANVAS_WIDTH / 2 + boxWidth / 2 + spacing / 2, boxY + 30);
                ctx.font = 'bold 36px Arial';
                ctx.fillText(gameState.greenScore, CONFIG.CANVAS_WIDTH / 2 + boxWidth / 2 + spacing / 2, boxY + 65);

                // Play again message
                ctx.fillStyle = '#aaa';
                ctx.font = '24px Arial';
                ctx.fillText('Click RESET to play again', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 260);
            }
        }

        function drawPlayer(x, y, color, isChaser) {
            // Shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 15;
            
            // Chaser glow
            if (isChaser) {
                const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, CONFIG.PLAYER_SIZE * 3);
                glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(x, y, CONFIG.PLAYER_SIZE * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Body
            const bodyGradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, CONFIG.PLAYER_SIZE);
            bodyGradient.addColorStop(0, color);
            bodyGradient.addColorStop(1, color + 'aa');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(x, y, CONFIG.PLAYER_SIZE, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - 6, y - 4, 4, 0, Math.PI * 2);
            ctx.arc(x + 6, y - 4, 4, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 6, y - 4, 2, 0, Math.PI * 2);
            ctx.arc(x + 6, y - 4, 2, 0, Math.PI * 2);
            ctx.fill();

            // Smile
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y + 4, 6, 0, Math.PI);
            ctx.stroke();

            // Chaser indicator ring
            if (isChaser) {
                ctx.strokeStyle = '#ffd93d';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, CONFIG.PLAYER_SIZE + 8, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function drawPowerup(x, y) {
            const time = Date.now() / 1000;
            const pulse = Math.sin(time * 5) * 0.3 + 1;

            // Outer glow
            const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, CONFIG.POWERUP_SIZE * 3 * pulse);
            glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
            glowGradient.addColorStop(0.5, 'rgba(255, 193, 7, 0.3)');
            glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(x, y, CONFIG.POWERUP_SIZE * 3 * pulse, 0, Math.PI * 2);
            ctx.fill();

            // Star shape
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(time * 2);

            // Shadow
            ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
            ctx.shadowBlur = 15;

            // Main star body
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, CONFIG.POWERUP_SIZE);
            gradient.addColorStop(0, '#fff44f');
            gradient.addColorStop(0.5, '#ffd93d');
            gradient.addColorStop(1, '#ffaa00');
            ctx.fillStyle = gradient;

            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x1 = Math.cos(angle) * CONFIG.POWERUP_SIZE;
                const y1 = Math.sin(angle) * CONFIG.POWERUP_SIZE;
                
                if (i === 0) {
                    ctx.moveTo(x1, y1);
                } else {
                    ctx.lineTo(x1, y1);
                }
                
                const angle2 = (angle + (2 * Math.PI) / 5);
                const x2 = Math.cos(angle2) * (CONFIG.POWERUP_SIZE * 0.4);
                const y2 = Math.sin(angle2) * (CONFIG.POWERUP_SIZE * 0.4);
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();

            // Inner highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(0, 0, CONFIG.POWERUP_SIZE * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Border
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x1 = Math.cos(angle) * CONFIG.POWERUP_SIZE;
                const y1 = Math.sin(angle) * CONFIG.POWERUP_SIZE;
                
                if (i === 0) {
                    ctx.moveTo(x1, y1);
                } else {
                    ctx.lineTo(x1, y1);
                }
                
                const angle2 = (angle + (2 * Math.PI) / 5);
                const x2 = Math.cos(angle2) * (CONFIG.POWERUP_SIZE * 0.4);
                const y2 = Math.sin(angle2) * (CONFIG.POWERUP_SIZE * 0.4);
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.stroke();

            ctx.restore();
            ctx.shadowBlur = 0;

            // Speed text above powerup
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText('SPEED', x, y - 25);
            ctx.fillText('SPEED', x, y - 25);
        }

        // Game Controls
        function startGame() {
            if (gameState.running) return;

            gameState.running = true;
            gameState.paused = false;
            gameState.time = CONFIG.ROUND_TIME;

            document.getElementById('startBtn').disabled = true;
            
            const chaserName = gameState.currentChaser === 'RED' ? 'RED' : 'GREEN';
            const evaderName = gameState.currentChaser === 'RED' ? 'GREEN' : 'RED';
            updateStatus(` Round started! ${chaserName} AI is chasing ${evaderName} AI!`);

            // Initialize first powerup spawn
            const firstSpawnDelay = (Math.random() * (CONFIG.POWERUP_SPAWN_MAX - CONFIG.POWERUP_SPAWN_MIN) + CONFIG.POWERUP_SPAWN_MIN) * 1000;
            gameState.powerupTimer = setTimeout(spawnPowerup, firstSpawnDelay);

            gameState.roundTimer = setInterval(() => {
                gameState.time--;
                
                if (gameState.time <= 0) {
                    clearInterval(gameState.roundTimer);
                    handleTimeUp();
                }
            }, 1000);

            gameLoop();
        }

        function handleTimeUp() {
            const evaderName = gameState.currentChaser === 'RED' ? 'GREEN' : 'RED';
            
            if (evaderName === 'GREEN') {
                gameState.greenScore++;
            } else {
                gameState.redScore++;
            }

            updateStatus(` Time's up! ${evaderName} AI escaped successfully! +1 point`);
            endRound();
        }

        function endRound() {
            gameState.running = false;

            if (gameState.roundTimer) {
                clearInterval(gameState.roundTimer);
            }

            if (gameState.powerupTimer) {
                clearTimeout(gameState.powerupTimer);
                gameState.powerupTimer = null;
            }

            // Clear powerup and reset boosts
            gameState.powerup = null;
            gameState.playerRed.speedBoost = 1;
            gameState.playerRed.boostTimer = 0;
            gameState.playerGreen.speedBoost = 1;
            gameState.playerGreen.boostTimer = 0;

            // Switch roles
            gameState.currentChaser = gameState.currentChaser === 'RED' ? 'GREEN' : 'RED';

            // Reset positions
            gameState.playerRed.x = 100;
            gameState.playerRed.y = 350;
            gameState.playerGreen.x = 900;
            gameState.playerGreen.y = 350;

            // Smooth transition with countdown
            if (gameState.redScore < CONFIG.WIN_SCORE && gameState.greenScore < CONFIG.WIN_SCORE) {
                gameState.transitioning = true;
                gameState.transitionCounter = 3;
                
                const countdownInterval = setInterval(() => {
                    gameState.transitionCounter--;
                    render();
                    
                    if (gameState.transitionCounter <= 0) {
                        clearInterval(countdownInterval);
                        gameState.transitioning = false;
                        startGame();
                    }
                }, 1000);
            } else {
                const winner = gameState.redScore >= CONFIG.WIN_SCORE ? 'RED' : 'GREEN';
                gameState.gameOver = true;
                gameState.winner = winner;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('startBtn').disabled = true;
                render(); // Show game over screen
            }
        }

        function togglePause() {
            if (!gameState.running) return;
            
            gameState.paused = !gameState.paused;
            document.getElementById('pauseBtn').textContent = gameState.paused ? ' RESUME' : ' PAUSE';
            
            if (!gameState.paused) {
                gameLoop();
            }
        }

        function resetGame() {
            gameState.running = false;
            gameState.paused = false;
            gameState.transitioning = false;
            gameState.gameOver = false;
            gameState.winner = null;
            gameState.time = CONFIG.ROUND_TIME;
            gameState.redScore = 0;
            gameState.greenScore = 0;
            gameState.currentChaser = 'RED';
            gameState.playerRed = { x: 100, y: 350, size: CONFIG.PLAYER_SIZE, speedBoost: 1, boostTimer: 0 };
            gameState.playerGreen = { x: 900, y: 350, size: CONFIG.PLAYER_SIZE, speedBoost: 1, boostTimer: 0 };
            gameState.powerup = null;

            if (gameState.roundTimer) {
                clearInterval(gameState.roundTimer);
            }

            if (gameState.powerupTimer) {
                clearTimeout(gameState.powerupTimer);
                gameState.powerupTimer = null;
            }

            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('pauseBtn').textContent = ' PAUSE';

            document.getElementById('chaserStats').textContent = 
                'Uses A* pathfinding to pursue the evader with optimal path calculation.';
            document.getElementById('evaderStats').textContent = 
                'Uses Potential Field + A* + Minimax to maintain maximum distance and never get caught.';

            updateStatus('Click START GAME to watch the ultimate AI battle!');
            render();
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Initialize on load
        initGame();
    </script>
</body>
</html>